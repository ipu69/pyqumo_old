/**
 * Module contains System class definition that serves as the DES scheduler,
 * events definitions, events handlers and main loop implementation.
 *
 * System class carries model clock and provides methods for events scheduling
 * and extracting events in the order of their appearance. Events are ordered
 * with their fire time and, if times of two events are equal, the order of
 * their creation.
 *
 * If DEBUG macro is defined, all handlers and service routines will put
 * _very_ detailed debug information during processing.
 *
 * @author Andrey Larionov
 */
#ifndef CQUMO_TANDEM_SYSTEM_H
#define CQUMO_TANDEM_SYSTEM_H

#include "Journals.h"
#include "Components.h"
#include <queue>


namespace cqumo {

/**
 * Types of events.
 */
enum EventType {
    STOP = 0,  ///< Event happens when simulation should be halted.
    SOURCE_TIMEOUT = 1,  ///< Source has a new packet.
    SERVER_TIMEOUT = 2   ///< Server finished processing a packet.
};


/** Get string representation of the event type. */
std::string toString(EventType eventType);


/**
 * Event structure.
 */
struct Event {
    unsigned id;  ///< ID of the event (unique in one simulation).
    double time;  ///< Model time when the event will happen.
    int address;  ///< Address of the node at which the event happens (optional)
    EventType type;   ///< Type of the event

    /** Get string representation of the event. */
    std::string toString() const;
};


typedef std::function<bool(Event *, Event *)> EventCmp;
typedef std::priority_queue<Event*, std::vector<Event*>, EventCmp> EventQueue;


/**
 * Discrete event simulation system (scheduler). Carries model clock, allows
 * to schedule new events and extract events one by one from the queue.
 *
 * Events are stored in the priority queue, where they are stored by their
 * fire time and IDs (for events with equal fire time). Template class
 * std::priority_queue with std::vector container is used to store events.
 *
 * Model time can be read, it changes when the next event is extracted
 * from the queue in nextEvent() call.
 *
 * If the events queue becomes empty, STOP event is returned by the system
 * to indicate that simulation should be stopped.
 */
class System {
  public:
    explicit System();

    /** Destroy the system instance and the queue with future events. */
    virtual ~System();

    /**
     * Schedule event in the future.
     * @param event type of event
     * @param interval non-negative timeout, after which the event will happen
     * @param address node address that will cause the event
     */
    void schedule(EventType event, double interval, int address);

    /**
     * Get next event from the events queue and move model clock to the fire
     * time of this event. If queue is empty, returns STOP event.
     * After processing, event SHOULD be deleted by the caller.
     */
    Event *nextEvent();

    /** Get current model time. */
    inline double time() const { return time_; }

    /** Check whether simulation was stopped. */
    inline bool stopped() const { return wasStopped_; }

    /** Set stopped flag indicating that simulation SHOULD be stopped. */
    inline void stop() { wasStopped_ = true; }

  private:
    EventQueue *eventsQueue_ = nullptr;
    double time_ = 0.0;
    unsigned nextId_ = 0;
    bool wasStopped_ = false;
};


/**
 * Helper routine that models start of packet processing by the server.
 * Processing algorithm:
 *
 * 1) A packet is pushed into the server.
 * 2) Get service interval from the server.
 * 3) Schedule SERVER_TIMEOUT (service end) with timeout equal to this interval.
 * 4) Record packet waiting time and update server size.
 *
 * @param server
 * @param packet
 * @param system
 * @param journal
 */
void startService(
        Server *server,
        Packet *packet,
        System *system,
        NetworkJournal *journal);

/**
 * Helper routine modeling packet arrival at the node. The packet may be just
 * generated by the source of this node, or come from another node after
 * completed service. Algorithm is like this:
 *
 * 1) Check whether server is ready. If so, start service immediately.
 * 2) If server is busy, try to enqueue the packet, if queue is not full.
 * 3) If queue was full, drop the packet and increment the number of dropped
 *      packets at this node journal, and the number of lost packets in the
 *      source node journal.
 * 4) If the packet was added to the queue or started service, update
 *      system and queue size statistics in this node journal.
 * 5) Increment the number of arrived packets in this node journal.
 *
 * @param packet
 * @param node
 * @param system
 * @param journal
 */
void handleArrival(
        Packet *packet,
        Node *node,
        System *system,
        NetworkJournal *journal);

/**
 * Handler for SOURCE_TIMEOUT event. Generates a new packet, passes it to
 * the node (@see handleArrival() helper), schedules new packet arrival and
 * record statistics about the number of generated packets in the node and
 * network journals.
 *
 * @param node
 * @param system
 * @param journal
 */
void handleSourceTimeout(Node *node, System *system, NetworkJournal *journal);

/**
 * Handler for SERVER_TIMEOUT event. Algorithm:
 *
 * 1) Record departure interval in this node journal.
 * 2) If the node address equals packet target, increment the number of
 *      delivered packets and record end-to-end delay in source node journal.
 *      After that, delete the packet.
 * 3) If the node is not the packet target, forward it to the next node
 *      (@see handleArrival() helper)
 * 4) If queue is not empty, extract one packet, update queue size records in
 *      this node journal and start serving the packet (@see startService()
 *      helper).
 * 5) Otherwise, if the queue is empty, record server size (0) in this
 *      node journal.
 * 6) Record updated system size in this node journal.
 *
 * @param node
 * @param system
 * @param journal
 */
void handleServerTimeout(Node *node, System *system, NetworkJournal *journal);

/**
 * Main simulation loop. Simulation consists of three phases:
 *
 * 1) Initialization:
 *      - set model time equal 0.0
 *      - reset network and nodes journals
 *      - schedule arrivals for all sources
 *
 * 2) Events processing till any stop condition reached, or events queue
 *      becomes empty.
 *
 * 3) Finalization: estimate performance metrics, clean service data.
 *
 * In current implementation the only stop condition is reaching the total
 * number of generated packets.
 *
 * If DEBUG macro is defined, all handlers and service routines will put
 * _very_ detailed debug information during processing.
 *
 * @param network
 * @param system
 * @param journal
 * @param maxPackets
 */
void runMainLoop(
        Network *network,
        System *system,
        NetworkJournal *journal,
        int maxPackets);

}

#endif //CQUMO_TANDEM_SYSTEM_H
